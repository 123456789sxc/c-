# 第 3 章   类和对象

## 3.1类和对象的基本概念

### 1.结构体的扩充及称谓

#### 1.1扩充

结构体是c语言自定义的一种数据类型，里面可以含有不同类型的数据。c++语言对结构体进行了扩充，使它不仅可以含有不同类型的数据，还可以含有函数。

#### 1.2称谓

c++中，通常将结构体中的数据称为数据成员，函数称为成员函数。(对类也是同样的)

### 2.类的声明

#### 2.1类和结构体的不同

类比结构体更安全，分为private和public；

类也是一种用户自定义的数据类型，但可以抽象化，类代表一批对象的共性和特征，类的成员是一种事物的共性和特征。而结构体的成员是根据用户的需要定义的。

#### 2.2类和结构体的私有共有以及作用范围

为保护类的数据安全，c++将类中成员分为私有成员(private)和公有成员(public)。

私有成员只能被类内的成员函数访问，公有成员既可被类内成员访问，也可被类外的对象访问。

默认情况下(即在没有指定属于私有还是公有时)，类中成员默认为私有，结构体默认为公有。

#### 2.3类的声明格式

```
class 类名{
    [private:]                     //[]中的内容表示有没有都行，这是常识
    私有数据成员和成员函数
    public:
    公有数据成员和成员函数
}；
```

#### 2.4注意

1.除了private，public之外，还有一个protected，现在不讲

2.一般情况下，一个类的数据成员为私有，成员函数为公有，这样，内部的数据隐蔽在类中，外部对象无法直接访问，保护了数据。

3.数据成员可以是任意数据类型，但是不能是extern，register，auto。这个没人会想到用这玩意，知道就好

### 3.成员函数

#### 3.1成员函数的两种定义方式

1.在类声明中只给出成员函数的声明。将函数的定义放在类外。类外定义格式为：

```
返回值类型  类名  ::成员函数名(参数表){
		函数体
}
```

```c++
class Point{
    public:
    void setPoint(int,int)；     //类内声明函数
    private:
    int x,y;
}
void Point ::setPoint(int a,int b){
    x=a;y=b;
}
```

注意：如果定义的类，没有类名，就不能用这种方式了，但是几乎碰不到不写类名的时候。这种定义方式是最常用的，类的定义简洁明了。

2.函数直接定义在类的内部。

这种定义方式，会将函数隐式定义为内联函数，即只要使用直接将函数定义在类的内部的，系统会默认将该函数定义为内联函数。这种定义方式适合简单的函数。一是代码复杂的内联函数会增加系统的工作量导致效率变低，二是代码复杂会导致类冗长复杂不容易看。

3.如果不管代码长不长都不想在类内定义函数的话，就用第一种方式。对于代码简单的函数，可以在类外定义的时候，用inline显式定义为内联函数。

### 4.对象定义及使用

#### 4.1对象的定义

##### 对象的两种定义方法(和结构体是一样的)

1.在声明类的同时，定义对象

```
class 类名{}对象1,对象2,...；
```

2.在声明类之后，定义对象

```
class 类名{};
类名 对象1,对象2,...;
```

##### 类的声明和定义对象关于存储空间的说明

声明一个类便是定义了一种数据类型，只有定义了对象，系统才会为对象分配存储空间。

#### 4.2对象对成员的访问

```
对象名.数据成员名
对象名.成员函数(实参表)
```

#### 4.3指向对象的指针的定义及对成员的访问 (跟结构体是一样的)

```
类名  *指针名 = &对象名;    //指针定义了就必须初始化，要不然系统会随机分配一个值，这样不利
```

```
指针名->数据成员
指针名->成员函数(实参表)
(*指针名).数据成员
(*指针名).成员函数(实参表)
```

## 3.2构造函数和析构函数

### 1.对象的初始化与构造函数

因为类是一种抽象的数据类型，所以在类的声明中不能对数据成员进行赋初值，结构体也是一样的。

在定义对象时，必须对每一个数据成员进行赋值，称为对象的初始化。

#### 1.1对公有成员进行初始化

```c++
class Complex{
    public:
    double real;
    double imag;
};
Comeplex c1={1.0,2.0}                     //对公有数据成员的初始化
```

#### 1.2对私有成员的初始化，只能通过成员函数。

c++有专门的函数用于私有数据成员的初始化，即构造函数

构造函数的特点：

构造函数是一种特殊的成员函数，只能用于与为对象分配空间，进行初始化。构造函数的名字必须和类名相同，它可以有任意类型的参数，但不能具有返回值类型。构造函数在建立对象时自动执行。

采用构造函数进行初始化的方法与两种

类名  对象名[实参表]

类名 *指针变量名=new 类名[实参表]

```c++
class Complex{
    private:
    double real;
    double imag;
    public:
    Complex(double r,double i){
        real=r;
        imag=i;
    }
};
Complex A(1.0,2.0);        //两种方式
Complex *pa=new Complex(1.0,2.0);    //定义了指向对象的指针，这个对象的名字是无名的
```

注意：构造函数一般声明为公有成员，但是不能被对象调用。只能在定义对象的时候自动调用，而且只能执行一次。

```
A.Complex(1.0,2.0)          //这种情况是错误的！
```

注意：如果在类的声明中没有写构造函数，系统会自动地生成一个默认构造函数，这个构造函数不带任何参数，而且函数体是空的。只要类中定义了构造函数，系统将不再提供默认构造函数。

构造函数可以不带参数，但是对对象的初始化时固定的。

#### 1.3用成员初始化列表对数据成员进行初始化//要求熟用

举例说明：

```c++
class Complex{
    private:
    double real;
    double imag;
    public:
    Complex(double r,double i);
}
Complex::Complex(double r,double i):real(r),imag(i){  //用成员初始化列表进行初始化
    
}
//等价于下面的
Complex::Complex(double r,double i){
    real=r;
    imag=i;
}
```

格式：

```
类名::构造函数名([参数表])[:(成员初始化列表)]{
            //构造函数体
};
//成员初始化列表的一般形式：
数据成员1(初始值1),数据成员2(初始值2),……;
```

注意：1.这种方法在构造函数定义的时候就可以使用，不用关心定义在类内还是类外

2.c++中某些类型的数据成员不允许在构造函数中用赋值语句直接赋值的。例如对于用const修饰的数据成员或者是引用类型的数据成员，是不允许用赋值语句直接赋值的。因此只能用成员初始化列表进行初始化。举例说明

```c++
class A{
    public:
    A(int x1){
        x = x1;
        rx = x;           //不能用赋值语句对类中的引用型数据进行赋值
        pi = 3.14;          //不能用赋值语句对const修饰的变量进行赋值，这两个是错误的
    }
    //用成员初始化列表
    A(int x1):x(x1),rx(x),pi(3.14){}     //不要忘了左右大括号
    private:
    int x;
    int &rx;     //不要在这里对引用型进行初始化
    const double pi;
};
```

3.数据成员是按照它们在类中的声明的顺序进行初始化的，与它们在初始化列表中的顺序无关。

```c++
class D{
    public:
    D(int i):m(i),n(m+1){         //3.列表初始化时，先初始化n,即n=m+1，因为m还未赋值，因此随机给m
        cout<<"m:"<<m<<endl;      //一个值，因此n初始化之后的值是随机的一个数，然后初始化m,m=15
        cout<<"n:"<<n<<endl;
    }
    private:
    int n,m;       //2.先定义的n后定义的m
};
int main(){
    D d(15);     //1.调用构造函数
    return 0;
}
```

### 2.构造函数的重载

### 3.带默认参数的构造函数

注意：1.当定义构造函数的时候，采用类内声明，类外定义的方式时，必须将默认参数写在类内构造函数声明中。

2.其实不管你构造函数重载也好，带默认参数也好，只要编译系统能识别每一个构造函数不产生二义性就行。隐蔽的一个就是，定义了一个无参构造函数，又定义了一个全默认参数的构造函数，因此在无实参初始化对象时会产生歧义。

### 析构函数

析构函数也是一种特殊的成员函数，它执行与构造函数相反的操作，如释放分配给对象的内存空间

#### 特点

1.析构函数名与类名相同，但它前面必须加一个波浪号~

2.析构函数没有返回值，没有参数，不能被重载

3.撤销对象时会自动执行析构函数

析构函数的定义形式与构造函数一样，不再赘述。

#### 注意

如果没有定义析构函数的话，会自动生成一个默认的析构函数，这个默认的析构函数的函数体是空的，但是能够完成释放对象内存空间的任务。如果一个对象在撤销之前需要完成另外一些工作的话，则应该显式的定义析构函数，同时，将要完成的任务写入函数体。显式定义也能完成释放对象内存空间的任务。

接下来写一个构造函数与析构函数的常见用法：

在构造函数中运用运算符new为字符串分配存储空间，最后在析构函数中运用运算符delete释放分配空间

```c++
class data{
    public:
    data(char *s){                  //构造函数初始化数组的方式
        str = new char[strlen(s)+1];
        strcpy(str,s);
    }
    ~data(){
        delete str;               //用完了释放，别占空间
    }
    private:
    char *str;
};
```

#### 使用情形：

1.主函数结束，或调用exit函数，对象会撤销。

2.如果一个对象被定义在函数体内，当函数调用结束的时候，对象被释放。

3.如果一个对象是new出来的，delete 对象的时候。

## 3.3对象数组与对象指针

对象数组是指数组的每一个元素都是同一个类的对象。

一维数组格式

```
类名 数组名[下标表达式]
```

在建立数组时，同样要调用构造函数。有几个元素就调用几次构造函数。

#### 创建数组时情形：

1.构造函数为无参或者全是默认参数时，这样定义：

```
Complex  a[10];       //定义一个Complex类的对象数组a，每个元素都调用了无参构造函数或者时全是默认参数的构造函数，这样定义的话，所有对象的初始值是一样的。
```

2.构造函数只有一个参数时：

```
Complex  a[4]={1，2，1，2};  
```

3.构造函数既有无参构造函数，又有一个参数构造函数时：

```
Complex   a[4]={1,2};      //前两个调用一个参数的构造函数，后两个调用无参构造函数
```

4.构造函数有多个参数的构造函数：

```
Complex  a[3]={
		Complex(1,2)
		Complex(2,3)
		Complex(3,4)
};                          //这样式的，构造函数并指明实参
```

#### 用对象指针访问对象数组

没必要讲，就是定义一个数组指针，把数组名赋给这个指针，然后指针叠加1就可以了

## 3.4  this指针

### 背景

当定义了一个类的若干对象后，系统会为每一个对象分配存储空间。如果一个类包含数据成员和成员函数，，就要分别为数据和函数的代码分配空间。给对象赋值就是给对象的数据成员赋值，，不同对象的存储单元中存放的数据值通常是不相同的，但是不同对象的函数代码是相同的。因此，没必要为每一个对象都开辟存储成员函数的空间。实际上，c++的编译系统只用了一段空间来存放这个共同的函数代码段，在调用各对象的成员函数时，都会去调用这个公用的函数代码。因此每个对象的存储空间都只是该对象数据成员所占用的存储空间。函数代码是存储在对象空间之外的。

即每一个对象有属于自己的数据成员，但是所有对象合用一份成员函数代码。

###  引出this指针

成员函数功能是对数据成员进行操作。当通过对象调用成员函数的时候，成员函数通过this指针实现对该对象的数据成员的操作。

this指针的值调用成员函数的对象的初始地址。即this指针指向调用成员函数的对象。

```c++
class A{
    public:
    A(int x1){
        x = x1;
    }
    void disp(){
        cout<<"x="<<x<<endl;
    }
};
//下面还是类A但是是经过编译系统处理过后的
class A{
    public:
    A(* this,int x1){
        this->x = x1;
    }
    void disp(){
        cout<<"x="<<this->x<<endl;
    }
}
int main(){
    A a(1),b(2);
    a.disp();          //编译系统处理后，新的调用方式为 a.disp(&a);     //this在这里被赋了值
    b.disp();
    return 0;
}
```

## 3.5 string类

### string类对象的定义和初始化

 使用string类必须要有#include  <string>

```c++
string str1,str2...;          //string类定义对象
string str3("china");
string str4 = "china";       //初始化的两种形式
```

### string类对象的运算符

| 运算符 |   示例   |              描述               |
| :----: | :------: | :-----------------------------: |
|   =    |  s1=s2   |          用s2给s1赋值           |
|   +    |  s1+s2   |         s2接到s1的后面          |
|   +=   |  s1+=s2  |         s2接到s1的后面          |
|   ==   |  s1==s2  |       判断s1和s2是否相等        |
|   !=   |  s1!=s2  |       判断s1和s2是否不等        |
|   <    |  s1<s2   |        判断s1是否小于s2         |
|   <=   |  s1<=s2  |      判断s1是否小于等于s2       |
|   >    |  s1>s2   |                                 |
|   >=   |  s1>=s2  |                                 |
|   []   |  s1[i]   | 访问字符串对象s1中下标为i的字符 |
|   <<   | cin>>s1  |                                 |
|   >>   | cout<<s1 |                                 |

##  3.6 向函数传递对象

### 使用对象作为函数参数(值传递)

### 使用对象指针作为函数参数(地址传递)

### 使用对象引用作为函数参数(地址传递)

## 3.7 对象的赋值和复制

### 对象的赋值(没必要讲)

赋值就是把一个对象的所有数据成员赋值给另一个对象的数据成员

格式： 对象1 =对象2； 

### 拷贝构造函数

拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。拷贝构造函数的作用是再建立一个新对象时，使用一个已经存在的对象去初始化这个新对象。它这个意思的初始化并不等同于赋值，它这个是什么意思呢？就是自由度非常大，可以选择性的复制数据成员，也可以在原数据成员的基础上进行扩大，比如扩大2倍啊啥的。

#### 特点

1.是一种构造函数。

2.只有一个参数且必须是同类对象的引用。(疑问：为什么非要是引用？拷贝构造函数的作用就是复制对象，得到一个新对象，为什么会需要引用？需要改变原对象吗？)

3.每个类必须有一个拷贝构造函数。程序员可以自定义，也可以由系统生成默认的。

#### 自定义的拷贝构造函数

格式:

```
类名::类名(const 类名 & 对象名){
          //函数体
};
```

 举个例子，说清拷贝构造函数和赋值的区别，就是对拷贝构造函数自由性的解释

```c++
class Point{
    public:
    Point(int a,int b){
        x= a;
        y= b;
    }
    Point(const Point &p){       //我就不理解了，非要搞个const，直接不要&引用不好了吗？
        x = 2*p.x;                   //不要引用，就是传递对象的地址给this指针。
        y = 2*p.x;          //体现构造函数的自由性
    }
    private:
    int x,y;
}；
```

#### 调用拷贝构造函数的一般形式

```
类名  对象2(对象1);
类名  对象2 = 对象1；     //注意注意注意，这个形式很像  对象的赋值语句
```

#### 默认拷贝构造函数

默认拷贝构造函数的功能是和对象赋值一样的！！！

好了，现在我们来梳理一下。

形式  对象2 = 对象 1   一定是对象赋值。

在默认拷贝构造函数的情况下，

调用拷贝构造函数的两种形式，也是 对象赋值。

在自定义拷贝函数的情况下，

调用拷贝构造函数的两种形式，就按照自定义的拷贝构造函数来。

#### 调用拷贝构造函数的三种情况(难点)

普通的构造函数会在对象创建的时候自动调用，拷贝构造函数会在一下三种情况下调用

1.当用类的一个对象在创建时，使用另一个对象作为参数。也就是调用拷贝构造函数的那两种形式。

2.当函数的形参是类的对象，调用函数时,会调用拷贝构造函数。(什么样的函数都行)

//1.这里我好像明白为什么在定义拷贝构造函数的时候要使用函数引用了。

//2.当调用这种函数时，会将实参通过拷贝构造函数传递给形参，在形参里执行操作

3.当函数的返回值是类的对象，在函数调用完毕将返回值返回到函数调用处的时候， 会调用拷贝构造函数。

## 3.8  静态成员

为了实现一个类的多个对象之间的数据共享，c++提出静态成员的概念。包括静态数据成员和静态函数成员。

### 静态数据成员

#### 定义格式

```
static 数据类型 数据成员名;
```

静态成员变量是在所有对象之外单独开辟空间，只要在类中定义了静态成员变量，即使不定义对象，也为静态成员变量分配空间，意思就是说，定义完类之后要给静态成员初始化。静态数据成员在对象被创建前就存在。

#### 初始化格式

```
数据类型 类名::静态数据成员名=初始值;      //注意初始化的时候没有加static
```

静态数据成员是属于类的，不像普通的数据成员那样属于某个对象，(对应于python的类属性和实例属性)因此

#### 访问格式

```
类名::静态数据成员             //不管静态数据成员是公有还是私有，都可以通过类名访问
```

```
对象名.静态数据成员                
对象指针->静态数据成员                    //静态数据成员只能是公有的，才能通过对象名访问
```

对于私有静态数据成员，跟普通的静态数据成员是一样的，要想通过对象访问，只能通过公有的成员函数。

### 静态成员函数

#### 定义格式

```
static 返回类型 静态成员函数名(参数表);       //类内声明
返回类型 静态成员函数名(参数表){}       //类外定义  跟静态数据成员初始化一样的，没有static
```

#### 访问格式

```
类名::静态成员函数名(实参表)          //公私有都能用类名访问的形式  
```

```
对象名.静态成员函数名(实参表)
对象指针.静态成员函数名(实参表)         //公有静态成员函数的访问可以通过对象名访问的两种形式
```

几乎没必要把成员函数设置成私有的吧。

#### 特点

1**.静态成员函数主要用于访问静态数据成员**，对数据成员进行操作。

2.静态成员函数可以在对象创建之前就调用，用以处理静态数据成员。这一点是普通成员函数不能实现的。

3.静态成员函数和非静态成员函数的区别还有，**静态成员函数是属于类的，没有this指针**，没有this指针意味着**不能**像非静态成员函数那样**直接就能访问非静态数据成员。**

一般而言，静态成员函数也不会访问类中的非静态成员。

如果确实需要静态成员函数访问非静态成员，只需要对象或对象引用或对象指针作为静态成员函数的形参就好了，到时候调用静态成员函数的时候传参就好了。

```c++
static void display(small &w){          //small是类名  形参是对象引用
    cout<<w.weight<<endl;               //weight是类的非静态数据成员，如果该静态成员函数没有对象引
}                                 //用作为函数参数的话，直接cout<<weight是不对的，因为没this指针
```

## 3.9   友元

### 友元函数

####    背景

类的私有成员(或保护成员)只能被类的成员函数访问。但是，有时候需要在类的外部访问类的私有成员(或保护成员)。在c++中，使用友元函数(独立于当前类的外部函数)访问所有成员。

定义格式

```
friend 返回类型 友元函数名(形参表)        //类内的声明

返回类型  友元函数名(形参表){                //类外定义，没有"类名::"，因为不是类内成员函数
         //函数体                          //不加friend
}                                         //必须要有对象名或对象指针或对象引用作为参数
```

举例

```c++
class Girl{
    Girl(char * n,int d){
        name = new char[strlen(n)+1];       //之前说过，构造函数与析构函数配合
        strcpy(name,n);
        age = d;
    }
    friend void disp(Girl &);         //友元函数的声明，在类中声明就是指是是该类的友元函数。
    ~Girl(){                           //但是友元函数不是类的成员函数
        delete name;
    }
    private:
    char * name;
    int age;
}；
void disp(Girl &x){
    cout<<x.name<<endl;        //因为x是对象，name是私有成员。这样x.name是不对的。但是disp是友元
                               //函数，这样就是对的。照你这样说，我有疑问
                               //第一，成员函数的形参能不能是本类的对象或对象指针或对象引用？
                               //应该是不可以的(不考虑拷贝构造函数).这也是友元函数不是成员函数的原因
}
int main(){
    Girl gl("sxc",20);
    disp(gl);
    return 0;
}
```

哎，有人就要问了，定义一个友元函数有什么用？仅仅是在类外定义的一个函数，用来访问类内的私有成员。我成员函数一样能对私有成员访问，要友元函数有什么用？

#### 当一个函数访问多个类时，友元函数就非常有用

举例：一个函数同时定义为两个类的友元函数

```c++
class Boy;            //对boy类提前声明，因为girl类的友元声明要用。
class Girl{
    public:
    friend void pa(const Girl&,const Boy&);       //声明函数pa为类Girl的友元
}
class Boy{
    public:
    friend void pa(const Girl&,const Boy&);
}
```

#### 将成员函数声明为友元函数

一个类的成员函数可以作为另一个类的友元函数。

```c++
class Girl;
class Boy{
    public:
    void disp(Girl &);              //声明函数disp是Boy类的成员函数
};
class Girl{
    public:
    friend void Boy::disp(Girl &);          //声明Boy的成员函数是类Girl的友元函数
}
void Boy::disp(Girl &x){
    //成员函数的定义放在最末尾
}
```

### 友元类

他妈的，不学啦

## 3.10常类型

### 常引用

### 常对象

### 常对象成员

#### 常数据成员

#### 常成员函数

# 第 4 章   派生类与继承

### 派生类的格式

```
class 派生类名:[继承方式] 基类名{                 //继承方式可以是public,private,protected
      //派生类新增的数据成员和成员函数                  //不写的话默认为private
};
```

派生类接受基类的全部成员(构造函数和析构函数除外)

派生类不能对基类成员进行选择性的接受，但是可以对这些成员进行某些调整。分为两方面，

1.改变这些成员在派生类中的访问属性。主要是通过派生类继承基类的**继承方式**来控制的。

2.派生类可以对这些成员进行重定义

### 继承方式对基类成员在派生类访问属性的影响

| 基类中的成员 | 在公有派生类中的访问属性 | 在私有派生类中的访问属性 | 在保护派生类中的访问属性 |
| ------------ | ------------------------ | ------------------------ | ------------------------ |
| 私有成员     | 不可直接访问             | 不可直接访问             | 不可直接访问             |
| 公有成员     | 公有                     | 私有                     | 保护                     |
| 保护成员     | 保护                     | 私有                     | 保护                     |

归纳：

1.基类中的私有成员不允许派生类继承

2.基类中的公有成员，什么样的继承方式，什么样的访问属性。

### 派生类的构造函数和析构函数

通常情况下，当创建派生类的对象的时候，首先执行基类的构造函数，然后再执行派生类的构造函数，当撤销派生类对象的时候，先执行派生类的析构函数，随后再执行基类的析构函数。

#### 派生类构造函数的一般格式

```
派生类名(参数总表):基类名(参数表){         //前面是形参表，后面是实参表。形参表有数据类型的。实参表没有
       派生类新增数据成员的初始化语句     //如果基类构造函数不用传参，也就是构造函数没有参数，:基类名(参数表)   就可以省略
}                                       //这是派生类构造函数的定义形式，可以在类内直接定义，也可以在类内声明，类外定义，不管类内还是类外，定义形式都是这个
派生类名(参数表)；           //派生类构造函数在类内的声明，
```

举例

```c++
#include <string>
class Student{
    public:
    Student(int number1,string name1,float score1){
        number = number1;
        name = name1;
        score = score1;
    }
    protected:
    int number;
    string name;
    float score;
};
class UStudent:public Student{
    public:
    UStudent(int number1,string name1,float score1,string major1):Student(number1,name1,score1){
        major = major1;
    }
    private:
    string major;
};
int main(){
    UStudent stu(123,"sxc",95,"cs");    //实参传递到派生类的构造函数，派生类构造函数提供将参数传递
    return 0;                           //到基类的构造函数的途径，先执行基类的构造函数
}
```

#### 派生类构造函数的补充

当派生类不需要显式定义构造函数的时候，只要基类的构造函数需要传参，那所有的派生类都必须定义构造函数，甚至所定义的派生类构造函数的函数体为空，仅仅起参数传递的作用。

### 派生类的析构函数

派生类的析构函数用来对派生类中所增加的成员进行清理。

基类的析构函数用来对基类中成员进行清理。

### 含有对象成员的派生类的构造函数

不写了。

## 同名成员

派生类对基类成员的重新定义。在派生类中使用该成员，使用的是重新定义的成员。如果想使用原先基类的成员，格式：

```
基类名::成员名
```

## 访问声明

## 多重继承

单继承是一个派生类只有一个基类。多重继承是一个派生类有多个基类。

### 多重继承的声明

class 派生类名:继承方式1 基类名1,……,继承方式n 基类名n{

//派生类新增数据成员和成员函数

}

### 多重继承的构造函数和析构函数

派生类名(参数总表):基类名1(参数表1),基类名2(参数表2),……,基类名n(参数表n){

//派生类新增成员的初始化语句

}

### 虚基类

有种情况是这样的，一个基类A有两个派生类B,C。一个派生类D多重继承B,C。A里面有一个数据成员a，继承到B,C。B,C里的a又继承到D里面。我们本意不是要区分D里面来自不同类的a(涉及多重继承的二义性)，而是让a只保留一次。引入虚基类的概念。



简单介绍多重继承的二义性：在上面的例子中，派生类D中有来自类B，C的数据成员a。创建一个类D 的对象 x

访问x.a会产生二义性。解决方法，使用域运算符::             例如x.B :: a



将基类A声明为虚基类后，当基类通过多条派生路径被一个派生类继承的时候，该派生类只继承一次来自基类的成员。意思是说，即使多条派生类路径都含有基类的成员，但被派生类继承后，只保留一次。

定义格式

class 派生类名:virtual 继承方式 基类名{

}

### 虚基类的初始化

## 基类与派生类对象之间的赋值兼容关系



# 第 5 章   多态性

## 5.1 编译时的多态性和运行时的多态性

### 5.1.1什么是多态？

在面向对象，多态性是指不同对象，收到相同的信息，产生不同的行为。在c++程序设计中，多态性是指用一个名字定义不同的函数，这些函数执行不同但又类似的操作。我们学的是c++面向对象，应该结合起来看。(不懂没关系，看下面怎么实现的，然后再看定义就ok了)

这里有一个会产生疑惑的地方，不同类的对象也算不同对象吧，那不同类的对象使用同名函数算不算多态呢？

不是，因为下面的实现里面，有函数重载,有运算符重载，有虚函数。不同类的对象使用同名函数不属于里面任何一个，所以不算多态。

### 5.1.2什么是联编

在c++中，多态的**实现**和**联编**这一概念有关。

联编的定义：联编分为静态联编和动态联编。静态联编是指源程序经过编译、连接等生成可执行文件的过程。

动态联编是运行可执行文件的过程。

静态联编在编译时就决定如何实现某一动作。这就要求程序在编译的时候就要知道调用函数的全部信息，不能产生歧义。主要通过函数重载(包括运算符重载)和模板(之后介绍)实现。

#### 什么是函数重载？

在同一个作用域中，如果有多个函数的名字相同，但是形参列表不同(参数类型不同或参数个数不同)，我们称之为重载函数。重载的函数是通过形参列表区分的，与返回值类型无关。函数重载其实是"一个名字，多种用法"的思想，不仅函数可以重载，运算符也可以重载。

举例说明运算符重载：

我们使用"+"号实现整型数之间，浮点数之间，双精度整型之间的加法运算。整型数之间，浮点数之间，双精度数之间的加法操作过程是不相同的，是使用不同内容的函数实现的。但是都是用的"+"号。这个例子使用的多态的特性，即发送同一个消息—相加，被不同类型的对象接受，采用不同的方法运算。

提问：不同类的同名函数是函数重载吗？ 回答：不是。

动态联编通过虚函数实现。**(当提出新概念的时候，不要怯，接着往下走就好了，等学到一定程度，再回头看就不会觉得蒙和难以理解了)**

接下来，先介绍静态联编实现，静态联编的实现包括函数重载，运算符重载。函数重载大家都知道，不再介绍

## 5.2运算符重载

运算符重载，就是**对已有的 运算符 重新进行定义， 赋予 其另一种功能，以适应不同的 数据类型** 。

举个例子，"+"号能实现对整型之间，浮点数之间等的加法运算。如果你新建一个类，想让两个该类的对象相加，直接用"+"号是行不通的。因为系统内置了对某些数据类型的重载函数，但是程序员自己新建的类，并没有对应的"+"号的重载函数。

### 下面介绍定义重载函数的三种形式

#### 5.2.1在类外定义的运算符重载函数

举例说明：

定义了类Complex，若要将类Complex的两个对象相加

格式

```c++
class Complex{
    public:                               //在类外定义的运算符重载函数只能访问公有数据成员！
    double real,imag;
    Complex(double r=0,double i=0){
        real=r;imag=i;                            //实现复数类
    }
}；
Complex operator+(Complex a1,Complex a2){      //格式   数据类型名 operator@(操作数参数){}
    Complex temp;                              //数据类型名也就是返回值类型。@表示要重载的运算符
    temp.real=a1.real+a2.real;                 //实部与实部相加，虚部与虚部相加
    temp.imag=a1.imag+a2.imag;
    return temp;
}
int main(){
Complex a1(1.0,2.0),a2(1.0,2.0),total;
total = a1+a2;            //调用+号的重载函数，还有另一种形式total=operator+(a1,a2)
return 0;
}
```

#### 运算符重载需要注意的地方

1.c++绝大部分运算符支持重载，不能重载的运算符有以下几个：

.   成员访问运算符     

.*       成员指针运算符

::      作用域运算符

Sizeof    长度运算符

?:           条件运算符

2.只能对已有的运算符重载。不允许用户自己定义新的运算符。

3.重载的功能应与原功能类似。

4.不能改变运算符操作数

5.不能改变优先级

6.不能改变原有的结合特性。例如左结合

7.运算符重载函数的参数至少有一个是类对象。不能全是c++标准。

#### 5.2.2友元运算符成员函数

因为类中的数据成员常常是私有成员和保护成员，为此采用友元重载和类的成员函数重载。

##### 定义格式

在类内定义，跟前面的比，就多一个friend

```
friend 函数类型 operator运算符（形参表）{
     函数体
}
```

在类内声明，在类外定义

```
class X{
 friend 函数类型 operator运算符（形参表）{
 }；
 
 函数类型 operator 运算符（形参表）{                        //形参表里放的是操作数
    函数体                                                //单目运算符就一个形参，双目就俩
 }
```

##### 调用方式

一般而言，如果类X中采用友元函数重载双目运算符，a,b是类X的两个对象，则以下两种调用方式是等价的：

a@b ；                      //隐式调用           @表示运算符

operator@（a，b）；      //显式调用

一般而言，如果类X中采用友元函数重载单目运算符，a是类X的对象，则以下两种调用方式是等价的：

@a；

operator@(a)；

##### 注意

1.运算符重载函数的返回值可以是任意数据类型，但一般是与它所操作的类型相同。

2.有些运算符不能使用友元重载，如赋值运算符"="，下标运算符"[]",函数调用运算符"()"

#### 5.2.3成员函数重载函数

##### 定义格式

在类内定义

```
函数类型 operator运算符(形参表){
          函数体
};
```

在类外定义

```
class X{
   函数类型 operator运算符(形参表);
};
函数类型  X::operator运算符(形参表){                   //以上三种运算符重载函数的定义格式区分清
       函数体                                       //我写的已经很明白了
}
```

##### 单双目运算符重载

对于双目运算符而言，成员运算符重载函数的形参表里有一个参数，作为运算符的右操作数。另一个操作数是隐含的，是该类的当前对象。通过this指针隐含传递给函数的。

```c++
class Complex{
    public:
    Complex operator+(Complex C);                      //通常一个类里面会重载很多运算符
    private:
    double real,imag;
};
Complex Complex::operator+(Complex C){         
    Complex temp;
    temp.real = real+c.real;
    temp.imag = imag + c.imag;
    return temp;
}
```

##### 调用方式

一般而言，如果在类X中采用成员函数重载双目运算符@，成员运算符函数operator@需要的一个操作数对象a通过this指针隐含传递，它的另一个操作数b在参数表中显示，则以下两种函数调用方法是等价的：

a@b;       //隐式调用

a.operator@(b);          //显式调用                                 与友元的那个不一样

对于单目运算符而言，成员函数形参表里没有参数，此时当前对象作为运算符的操作数。

成员函数单目重载运算符的调用方式类比上面就好了。

### 5.2.4成员运算符重载函数与友元运算符重载函数比较

1.对双目运算符而言，成员运算符重载函数参数表中含有一个参数，而友元运算符重载函数参数表中含有两个参数；对于单目运算符而言，成员运算符重载函数参数表中没有参数，而友元运算符重载函数参数表中有一个参数。

2.双目运算符一般可以被重载为友元运算符重载函数或成员运算符重载函数，但是有一种情况必须使用友元函数。

举例说明：

```c++
//将一个复数与一个整数相加，用成员运算符函数重载"+"运算符
Complex operator+(int a){
    return (real+a,imag);      //这条语句应该是返回给Complex对象，即创建对象，调用构造函数
}
//若com和com1是类Complex的对象，则以下语句是正确的；
com1=com+100;        //被编译系统解释为com1=com.operator(100);
//以下语句是错误的
com1=100+com;     //被编译系统解释为com1=100.operator(com);       这一看就是错的啊
```

因此这是成员运算符重载函数应该注意的地方。相反，如果是友元运算符重载函数就不会产生这样的错误了。

3.成员运算符函数和友元运算符函数都可以用习惯的方式调用，也可以用专门的调用方式。

| 习惯形式 | 友元专用调用方式 | 成员函数专用调用方式 |
| -------- | ---------------- | -------------------- |
| a+b      | operator+(a,b)   | a.operator+(b)       |
| - a      | operator-(a)     | a.operator-()        |
| a++      | operator++(a,0)  | a.operator++(0)      |

我仔细看了，都还是挺有特点的

4.经验

c++大部分运算符既可以说明为成员运算符重载函数又有可以说明为友元运算符重载函数。究竟选择哪一种运算符函数好一些？一般而言，对于双目运算符，友元更好用。对于单目运算符，成员函数更好用。

如果运算符所需的操作数(尤其是第一个操作数)希望有隐式类型转换，则运算符重载必须使用友元函数。(疑问，不理解)

以下经验可供参考：

1.对于运算符"=、()、[]、->"只能作为成员函数

2.对于运算符"+=、-=、/=、*=、&=、!=、~=、%=、<<=、>>="建议重载为成员函数

3.对于其他运算符，建议重载为友元函数。

### 5.2.5       "++"和"--"的重载

"++"和"--"放置在变量前后，其作用是有区别的。在重载"++"或"--"时，不能显式地区分时前缀方式还是后缀方式。

由于编译器必须能够识别出前缀自增与后缀自增，人为规定用 operator++() 和 operator–() 重载前置运算符，用 operator++(int) 和 operator–(int) 重载后置运算符，在这里的 int 并没有什么实际的意义，仅仅是为了区分重载的是前置的形式还是后置的形式。

看到++a(前置++)，它就调用operator++(a),当编译器看到a++（后置++），它就会去调用operator++(a,int).

### 5.2.6     赋值"="运算符的重载

对任一类X，如果没有用户自动逸的赋值运算符函数，那系统将自动为其生成一个默认的赋值运算符函数。例如a和b是X的两个对象，执行a=b，是将b的数据成员逐域复制到对象a中。

### 5.2.7      下标运算符[]的重载

## 5.3类型转换

## 5.4 虚函数

### 说明

在c++中规定：基类的对象指针可以指向它的**公有派生**的对象，但是当其指向共有派生类对象时，只能访问派生类中从基类继承来的成员，不能访问共有派生类中定义的成员。

```c++
class X{
    public:
    X(int x,int y){
        a = x;
        b = y;
    }
    void show(){
        cout<<"调用基类的show函数";
    }
    private:
    int a,b;
};
class A:public X{
    A(int x,int y,int z):X(x,y){
        c=z;
    }
    void show(){
        cout<<"调用基类的show函数";
    }
    private:
    int c;
};
int main(){
	X m1(1,1),*mp;
	A m2(1,1,1);
	mp=&m1;
	mp->show();                      //基类对象指针指向基类对象，执行基类的show函数
	mp=&m2;
	mp->show();                       //基类对象指针指向公有派生类对象，还是执行基类的show函数
    return 0;                       //如果show函数是虚函数的话，就会执行派生类的show函数
}
```

### 虚函数定义

虚函数就是在基类中被关键字virtual说明，并在派生类中重新定义的函数。

举例

定义了基类Animal，Animal是一个抽象类。cat类和dog类是具体类。在抽象类里定义了虚函数eat，说明所有动物都有吃这个功能，具体到实例，eat的具体功能又不相同，即基类中重新定义。

```c++
class Animal{ 
    virtual void eat()=0;          //纯虚数
};
class cat:public Animal{
    virtual void eat(){
        cout<<"cat eat fish";
    }
};
class dog:public Animal{
    virtual void eat(){
        cout<<"dog eat meat";
    }
};
```

### 定义格式

在类内定义

```
virtual 函数类型 函数名(形参表){            //就是成员函数多了virtual
             函数体
}
```

在类内声明，在类外定义

在类内声明有virtual，在类外定义的时候不要

### 注意

1.虚函数也是成员函数，和成员函数在子类中重新定义是一样的。成员函数在子类中重新定义会在子类中隐藏基类的成员函数。

2.虽然使用对象名和点运算符分方式也能调用虚函数，但是这种调用是在编译时进行的，是静态编译。**只有通过基类指针访问虚函数时才能获得运行时的多态性**

总结：

前提：有公有继承。

基类的成员函数在子类中的重新定义是在子类中隐藏了基类的成员函数。

访问成员函数的两种方式：

对象和指针。

对象访问的话在前面章节同名成员里介绍了

这次主要是介绍指针。

c++的规则，基类指针指向基类对象和子类对象的时候，通过指针访问成员函数时，都是访问的基类的成员函数，而不是指向基类对象的时候，访问基类的成员函数；指向子类对象的时候，访问子类的成员函数。这并不符合多态性，即不同对象接受同一信息实现不同的功能。这个是，不同对象接受同一信息执行了同一函数。我们现在想要当基类指针指向子类对象，调用函数的时候，执行子类重新定义的函数，而不是执行基类的函数。这时将函数定义为虚函数就可以。

另一方面，只有通过基类指针访问虚函数时才能获得运行时多态性。

运行时多态性要保证基类指针访问，和虚函数。

虚函数的另一重要特性是给抽象类定义抽象的功能声明，也就是纯虚数，用于实现子类的具体功能。

纯虚数格式

```
virtual 函数类型 函数名(形参表) = 0;
```

运行时多态性的主要实现，我觉得应该是一个基类指针在指向多个子类的对象的时候，执行虚函数的时候，执行的是所指向的子类对象重新定义的函数，这就很能说明运行时多态。

## 5.5虚析构函数

