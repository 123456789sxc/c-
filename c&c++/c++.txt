区分重载(overload)，覆盖(Override)和隐藏(hide) 收藏
重载overload，这个概念是大家熟知的。在同一可访问区内被声名的几个具有不同参数列的（参数的类型、个数、顺序不同）同名函数，程序会根据不同的参数列来确定具体调用哪个函数，这种机制就是重载。重载不关心函数的返回值类型，即返回类型不同无法构成重载。此外，C++ 中的const成员函数也可以构成overload。
总结一下重载的特征：
　　1、处在相同的空间中，即相同的范围内；
　　2、函数名相同；
　　3、参数不同，即参数个数不同，或相同位置的参数类型不同；
　　4、const成员函数可以和非const成员函数形成重载；
5、virtual关键字、返回类型对是否够成重载无任何影响。


覆盖override，是指派生类中存在重新定义的函数，其函数名、参数列、返回值类型必须同父类中的相对应被覆盖的函数严格一致，覆盖函数和被覆盖函数只有函数体（花括号中的部分）不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本，这种机制就叫做覆盖，特征是：
1、不同的范围（分别位于派生类与基类）；
2、函数名字相同；
3、参数相同；
4、基类函数必须有virtual关键字。

针对上述两个概念，还有一个隐藏hide。所谓的隐藏，指的是派生类类型的对象、指针、引用访问基类和派生类都有的同名函数时，访问的是派生类的函数，即隐藏了基类的同名函数。隐藏规则的底层原因其实是Ｃ＋＋的名字解析过程。在继承机制下，派生类的类域被嵌套在基类的类域中。派生类的名字解析过程如下：
　　1、首先在派生类类域中查找该名字。
　　2、如果第一步中没有成功查找到该名字，即在派生类的类域中无法对该名字进行解析，则编译器在外围基类类域对查找该名字的定义。
总结一下隐藏的特征：
1、如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。